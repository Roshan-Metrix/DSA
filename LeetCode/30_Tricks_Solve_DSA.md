# Top 30 DSA Patterns 

## 1. 🌀 Sliding Window
Used in problems like maximum sum subarray, longest substring without repeating characters, or minimum window substring. Dynamically maintain a window over arrays or strings for optimized performance.

**Why it matters:**  
Transforms brute-force O(n²) solutions into efficient O(n) ones. Essential for string and subarray problems.

---

## 2. 2️⃣ Two Pointers
Common in 3Sum, sorted array intersection, remove duplicates, or container with most water. Involves scanning from both ends of a sorted input.

**Why it matters:**  
Optimizes time and space, encourages elegant code, and tests pointer logic.

---

## 3. 🐢 Fast & Slow Pointers
Used for detecting cycles in linked lists (Floyd's algorithm), finding the middle node, or Happy Number problems.

**Why it matters:**  
Identifies cycles and intersections without extra space. Tests pointer behavior over iterations.

---

## 4. 🌍 Merge Intervals
Shines in merging meeting schedules, inserting intervals, or finding common time slots.

**Why it matters:**  
Tests sorting and overlap logic. Popular in scheduling and real-life systems.

---

## 5. 🔎 Binary Search
Solves search in rotated array, find element in sorted matrix, or minimum in rotated array.

**Why it matters:**  
Foundation for advanced algorithmic problems. Demonstrates logarithmic thinking and edge case management.

---

## 6. 🧮 Prefix Sum
Helpful for range sum queries, subarrays equal to K, or finding equilibrium index.

**Why it matters:**  
Optimizes via pre-computation. Essential for efficient problem-solving.

---

## 7. 🧠 Dynamic Programming (1D)
Used in Climbing Stairs, Fibonacci, House Robber, and similar recursive/memoization problems.

**Why it matters:**  
Breaks problems into subproblems and builds bottom-up solutions.

---

## 8. ⛓ Dynamic Programming (2D / Grid)
Appears in Unique Paths, Edit Distance, Longest Common Subsequence, and matrix-based challenges.

**Why it matters:**  
Evaluates multi-dimensional state transitions. Prepares for real-world multi-dimensional challenges.

---

## 9. 🏛️ Topological Sort
Solves Course Schedule, Build Order, and Alien Dictionary.

**Why it matters:**  
Foundational for dependency resolution in directed acyclic graphs (DAGs).

---

## 10. 🌊 Breadth-First Search (BFS)
Used in shortest path, Word Ladder, or level order traversal of trees.

**Why it matters:**  
Layer-by-layer searching. Demonstrates queue-based logic.

---

## 11. 🧗 Depth-First Search (DFS)
Great for Number of Islands, Maze Solvers, and Graph Traversal.

**Why it matters:**  
Explores paths deeply before backtracking. Teaches recursion and graph exploration.

---

## 12. 🔗 Linked List Manipulation
Examples: reversing a list, detecting cycles, merging sorted lists.

**Why it matters:**  
Tests understanding of pointers and memory. Teaches robust, bug-free code.

---

## 13. 🧱 Union-Find (Disjoint Set)
Useful in Connected Components, Graph Valid Tree, Accounts Merge.

**Why it matters:**  
Powerful for connectivity and networks. Combines logic, optimization, and modeling.

---

## 14. ⏪ Backtracking
Think N-Queens, Sudoku Solver, Permutations.

**Why it matters:**  
Tries every possible option under constraints. Highlights recursion tree building and pruning.

---

## 15. 📈 Kadane’s Algorithm
Finds maximum subarray sum, including circular variants.

**Why it matters:**  
Optimizes greedy behavior dynamically. Turns nested loops into linear time solutions.

---

## 16. 📊 Monotonic Stack
Used in Largest Rectangle in Histogram, Next Greater Element, Daily Temperatures.

**Why it matters:**  
Shows depth in stack-based thinking and real-time window problems.

---

## 17. 🧬 Trie (Prefix Tree)
Great for autocomplete, search suggestions, word dictionaries.

**Why it matters:**  
Efficient for prefix search. Demonstrates tree structures and string indexing.

---

## 18. 📉 Heap / Priority Queue
Used in Top K elements, Median Finder, Dijkstra’s algorithm.

**Why it matters:**  
Prioritizes processing efficiently. Essential for dynamic sorting and stream processing.

---

## 19. 🔢 Bit Manipulation
Helpful in Single Number, Count Set Bits, Power of Two.

**Why it matters:**  
Tests low-level thinking. Ultra-efficient for space-constrained, performance-critical applications.

---

## 20. 🧭 Matrix Traversal
Use in Spiral Matrix, Flood Fill, Word Search.

**Why it matters:**  
Navigates 2D data. Essential for image processing, maps, and simulations.

---

## 21. 🧪 Counting Patterns
Appears in Good Triplets, Counting Pairs, Anagram Grouping.

**Why it matters:**  
Teaches combinatorics and hash-based grouping. Assesses frequency tracking and hash map usage.

---

## 22. 🎰 Bucket Sort / Counting Sort
Used in Top K Frequent Elements, Sort Colors, Frequency Sorting.

**Why it matters:**  
Efficient sorting when range is known. Demonstrates time-space trade-offs.

---

## 23. 🌳 Recursion Trees
Used in subset problems, backtracking, divide & conquer.

**Why it matters:**  
Makes time complexity analysis easier. Builds elegant recursive solutions.

---

## 24. 📦 Stack + Queue Hybrid
Seen in Implement Queue using Stack, Evaluate Expressions, Min Stack.

**Why it matters:**  
Tests data structure creativity. Simulating one structure with another shows deep understanding.

---

## 25. 🗺 Graph Traversals with Weights
Used in Dijkstra’s, A* Search, Minimum Spanning Tree.

**Why it matters:**  
Pushes graph theory and algorithm knowledge. Crucial for network-heavy problems.

---

## 26. 🧩 Matrix DP
Appears in Minimum Path Sum, Unique Paths with Obstacles, Coin Change II.

**Why it matters:**  
Combines dynamic programming and grid traversal. Showcases caching state across 2D space.

---

## 27. ⚖ Pattern Matching
Used in KMP Algorithm, Rabin-Karp, Wildcard Matching.

**Why it matters:**  
Shows string searching and hashing knowledge. Important for compilers, search engines, NLP.

---

## 28. 🌴 Segment Trees
Solves range query problems, sum/range max, lazy propagation.

**Why it matters:**  
Essential for high-performance data queries. Demonstrates algorithmic depth and optimization.

---

## 29. 📖 Sliding Window + Hashing
Appears in Minimum Window Substring, Anagram Checking, Longest Repeating Substring.

**Why it matters:**  
Combining patterns shows smart algorithm composition. Crucial for efficient, scalable solutions.

---

## 30. 🔄 In-place Transformations
Used in rotate matrix, reverse words in place, flatten binary tree.

**Why it matters:**  
Tests memory discipline. Optimizes space without sacrificing clarity or correctness.
